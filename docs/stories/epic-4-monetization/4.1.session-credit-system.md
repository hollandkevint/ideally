# Story 4.1: Session Credit System

## Status
⏳ **READY TO START** - Prerequisites identified

## Implementation Priority
**Priority**: Critical (Enables Revenue)
**Dependencies**: None (First story in Epic 4)
**Estimated Effort**: 2 days
**Complexity**: Medium

## Story
**As a** user who wants to use ThinkHaven's AI coaching platform,
**I want** a transparent session credit system with a freemium trial,
**so that** I can try the platform for free and purchase additional sessions when I see value.

## Acceptance Criteria
1. **Credit Balance Tracking**: Users have a visible credit balance that shows available sessions
2. **Freemium Trial**: New users automatically receive 1 free session credit upon registration
3. **Session Validation**: Session creation validates credit availability before allowing AI interaction
4. **Credit Deduction**: Starting a session deducts 1 credit from user's balance
5. **Low Credit Warnings**: Users see warnings when credits are low (0-1 remaining)
6. **Credit Purchase Flow**: Users can view pricing and purchase credit packages (integrated with Stripe)

## Prerequisites (Before Implementation)

### 1. Stripe Account Setup
**Required Actions**:
- [ ] Create Stripe account at stripe.com
- [ ] Complete business verification
- [ ] Set up test mode (for development)
- [ ] Set up live mode (for production)
- [ ] Generate API keys (test + live)
- [ ] Configure webhook endpoints

**Documentation**:
- Stripe Dashboard: https://dashboard.stripe.com
- API Keys location: Dashboard → Developers → API keys

### 2. Email Service Setup
**Required Actions**:
- [ ] Choose email provider (Resend, SendGrid, or AWS SES)
- [ ] Create account and verify domain
- [ ] Generate API key
- [ ] Set up email templates for:
  - Welcome email with free credit
  - Payment confirmation
  - Low credit warnings
  - Receipt delivery

**Recommendation**: Resend (modern, React email templates, great DX)

### 3. Legal Documents
**Required Actions**:
- [ ] Draft Terms of Service (ToS)
- [ ] Draft Privacy Policy
- [ ] Draft Refund Policy
- [ ] Legal review (if required)
- [ ] Create acceptance flow in UI

**Critical Sections to Include**:
- Payment terms and billing
- Credit expiration policy
- Refund conditions
- Data usage and privacy
- Service availability (uptime SLA)

## Tasks / Subtasks

- [ ] Task 1: Database Schema for Credits (AC: 1)
  - [ ] Subtask 1.1: Create `user_credits` table with balance, granted, purchased fields
  - [ ] Subtask 1.2: Create `credit_transactions` table for audit trail
  - [ ] Subtask 1.3: Add RLS policies for user data protection
  - [ ] Subtask 1.4: Create indexes for performance
  - [ ] Subtask 1.5: Write migration script

- [ ] Task 2: Freemium Trial Implementation (AC: 2)
  - [ ] Subtask 2.1: Add trigger to grant 1 free credit on user registration
  - [ ] Subtask 2.2: Create welcome email with free credit notification
  - [ ] Subtask 2.3: Update onboarding flow to highlight free session
  - [ ] Subtask 2.4: Track freemium conversions (analytics)

- [ ] Task 3: Session Validation & Credit Deduction (AC: 3, 4)
  - [ ] Subtask 3.1: Create `check_credit_balance` API endpoint
  - [ ] Subtask 3.2: Implement `deduct_credit` transaction (atomic)
  - [ ] Subtask 3.3: Update session creation to validate credits
  - [ ] Subtask 3.4: Add credit deduction logging
  - [ ] Subtask 3.5: Handle edge cases (concurrent sessions, race conditions)

- [ ] Task 4: Credit Balance UI (AC: 1, 5)
  - [ ] Subtask 4.1: Create `CreditIndicator` component for nav/header
  - [ ] Subtask 4.2: Add low credit warning modal (0-1 credits)
  - [ ] Subtask 4.3: Create credit history view
  - [ ] Subtask 4.4: Add tooltips explaining credit usage
  - [ ] Subtask 4.5: Design upgrade CTA for zero credits

- [ ] Task 5: Credit Purchase Integration (AC: 6)
  - [ ] Subtask 5.1: Create Stripe product catalog (3 tiers)
  - [ ] Subtask 5.2: Build `create_checkout_session` API endpoint
  - [ ] Subtask 5.3: Implement Stripe webhook handler (`checkout.session.completed`)
  - [ ] Subtask 5.4: Add credits on successful payment
  - [ ] Subtask 5.5: Send payment confirmation email

- [ ] Task 6: Testing & Edge Cases (All ACs)
  - [ ] Subtask 6.1: Unit tests for credit deduction logic
  - [ ] Subtask 6.2: Integration tests for Stripe flow
  - [ ] Subtask 6.3: E2E tests for freemium journey
  - [ ] Subtask 6.4: Test race conditions (multiple sessions)
  - [ ] Subtask 6.5: Test webhook reliability and retries

## Dev Notes

### Database Schema

```sql
-- User credit balance
CREATE TABLE user_credits (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references auth.users unique not null,
  balance integer default 0 not null check (balance >= 0),
  total_granted integer default 0 not null,
  total_purchased integer default 0 not null,
  total_used integer default 0 not null,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Credit transaction audit trail
CREATE TABLE credit_transactions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references auth.users not null,
  transaction_type text check (transaction_type in ('grant', 'purchase', 'deduct', 'refund')) not null,
  amount integer not null,
  balance_after integer not null,
  session_id uuid references bmad_sessions(id),
  stripe_payment_id text,
  description text,
  created_at timestamptz default now()
);

-- Trigger to grant free credit on registration
CREATE OR REPLACE FUNCTION grant_free_credit()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO user_credits (user_id, balance, total_granted)
  VALUES (NEW.id, 1, 1);

  INSERT INTO credit_transactions (user_id, transaction_type, amount, balance_after, description)
  VALUES (NEW.id, 'grant', 1, 1, 'Welcome! Your first session is on us.');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION grant_free_credit();

-- RLS policies
ALTER TABLE user_credits ENABLE ROW LEVEL SECURITY;
ALTER TABLE credit_transactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own credits" ON user_credits
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can view own transactions" ON credit_transactions
  FOR SELECT USING (auth.uid() = user_id);
```

### Stripe Integration Pattern

```typescript
// lib/monetization/stripe-service.ts
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

export const CREDIT_PACKAGES = {
  starter: { credits: 5, price: 1900, priceId: 'price_starter' }, // $19
  professional: { credits: 10, price: 3900, priceId: 'price_pro' }, // $39
  business: { credits: 20, price: 7900, priceId: 'price_business' }, // $79
};

export async function createCheckoutSession(
  userId: string,
  packageType: keyof typeof CREDIT_PACKAGES
) {
  const pkg = CREDIT_PACKAGES[packageType];

  const session = await stripe.checkout.sessions.create({
    mode: 'payment',
    payment_method_types: ['card'],
    line_items: [{
      price: pkg.priceId,
      quantity: 1,
    }],
    success_url: `${process.env.APP_URL}/dashboard?purchase=success`,
    cancel_url: `${process.env.APP_URL}/pricing?purchase=cancelled`,
    metadata: {
      userId,
      credits: pkg.credits.toString(),
      packageType,
    },
  });

  return session;
}
```

### Credit Deduction Service

```typescript
// lib/monetization/credit-manager.ts
import { createClient } from '@/lib/supabase/server';

export async function deductCredit(userId: string, sessionId: string) {
  const supabase = createClient();

  // Atomic transaction
  const { data, error } = await supabase.rpc('deduct_credit_transaction', {
    p_user_id: userId,
    p_session_id: sessionId,
  });

  if (error || !data.success) {
    throw new Error(data?.message || 'Insufficient credits');
  }

  return data;
}

// Database function for atomic credit deduction
/*
CREATE OR REPLACE FUNCTION deduct_credit_transaction(
  p_user_id uuid,
  p_session_id uuid
) RETURNS jsonb AS $$
DECLARE
  v_balance integer;
  v_new_balance integer;
BEGIN
  -- Lock row and get balance
  SELECT balance INTO v_balance
  FROM user_credits
  WHERE user_id = p_user_id
  FOR UPDATE;

  IF v_balance IS NULL THEN
    RETURN jsonb_build_object('success', false, 'message', 'User credits not found');
  END IF;

  IF v_balance < 1 THEN
    RETURN jsonb_build_object('success', false, 'message', 'Insufficient credits');
  END IF;

  -- Deduct credit
  v_new_balance := v_balance - 1;

  UPDATE user_credits
  SET balance = v_new_balance,
      total_used = total_used + 1,
      updated_at = now()
  WHERE user_id = p_user_id;

  -- Log transaction
  INSERT INTO credit_transactions (user_id, transaction_type, amount, balance_after, session_id)
  VALUES (p_user_id, 'deduct', -1, v_new_balance, p_session_id);

  RETURN jsonb_build_object('success', true, 'balance', v_new_balance);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
*/
```

### UI Components

**CreditIndicator Component**:
```typescript
// app/components/monetization/CreditIndicator.tsx
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';

export function CreditIndicator() {
  const [credits, setCredits] = useState<number | null>(null);
  const supabase = createClient();

  useEffect(() => {
    async function fetchCredits() {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data } = await supabase
        .from('user_credits')
        .select('balance')
        .eq('user_id', user.id)
        .single();

      setCredits(data?.balance ?? 0);
    }

    fetchCredits();
  }, []);

  const isLow = credits !== null && credits <= 1;

  return (
    <div className={`flex items-center gap-2 ${isLow ? 'text-orange-600' : ''}`}>
      <span className="text-sm font-medium">
        {credits !== null ? `${credits} ${credits === 1 ? 'credit' : 'credits'}` : '...'}
      </span>
      {isLow && (
        <button className="text-xs underline" onClick={() => router.push('/pricing')}>
          Add credits
        </button>
      )}
    </div>
  );
}
```

### Email Templates (Resend)

```typescript
// lib/email/templates/welcome-credit.tsx
import { Html, Head, Body, Container, Text, Button } from '@react-email/components';

export function WelcomeCreditEmail({ userName }: { userName: string }) {
  return (
    <Html>
      <Head />
      <Body style={{ fontFamily: 'sans-serif' }}>
        <Container>
          <Text>Hi {userName},</Text>
          <Text>Welcome to ThinkHaven! 🎉</Text>
          <Text>
            Your first strategic coaching session is on us. We've added 1 free credit to your account.
          </Text>
          <Button href={`${process.env.APP_URL}/dashboard`}>
            Start Your Free Session
          </Button>
          <Text>
            Each session gives you 30 minutes with Mary, our AI strategic coach, to refine ideas,
            build business models, or create professional feature briefs.
          </Text>
        </Container>
      </Body>
    </Html>
  );
}
```

### API Endpoints

**Credit Balance Endpoint**:
```typescript
// app/api/credits/balance/route.ts
import { createClient } from '@/lib/supabase/server';

export async function GET() {
  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { data, error } = await supabase
    .from('user_credits')
    .select('balance, total_granted, total_purchased, total_used')
    .eq('user_id', user.id)
    .single();

  if (error) {
    return Response.json({ error: error.message }, { status: 500 });
  }

  return Response.json(data);
}
```

**Stripe Webhook Handler**:
```typescript
// app/api/stripe/webhook/route.ts
import Stripe from 'stripe';
import { headers } from 'next/headers';
import { addCredits } from '@/lib/monetization/credit-manager';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function POST(req: Request) {
  const body = await req.text();
  const signature = headers().get('stripe-signature')!;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    return Response.json({ error: 'Invalid signature' }, { status: 400 });
  }

  if (event.type === 'checkout.session.completed') {
    const session = event.data.object as Stripe.Checkout.Session;

    await addCredits({
      userId: session.metadata!.userId,
      credits: parseInt(session.metadata!.credits),
      stripePaymentId: session.payment_intent as string,
    });
  }

  return Response.json({ received: true });
}
```

## Testing Requirements

### Unit Tests
- Credit deduction logic (atomic transactions)
- Race condition handling (concurrent sessions)
- Freemium grant trigger

### Integration Tests
- Stripe checkout session creation
- Webhook event processing
- Email delivery

### E2E Tests (Playwright)
- New user registration → free credit grant
- Session creation with credit validation
- Credit purchase flow (Stripe test mode)
- Low credit warning display

## Performance Requirements
- Credit balance check: <100ms
- Credit deduction: <200ms (with transaction lock)
- Stripe checkout creation: <1 second
- Webhook processing: <3 seconds

## Security Considerations
- **Atomic Transactions**: Prevent double-spending with database locks
- **Stripe Webhook Verification**: Validate signatures to prevent fraud
- **RLS Policies**: Users can only access their own credit data
- **API Rate Limiting**: Prevent abuse of credit check endpoints
- **Audit Trail**: All credit changes logged in `credit_transactions`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-09 | 1.0 | Initial story creation - Session credit system with freemium trial | Development Team |

## Implementation Plan

### Day 1: Database + Core Logic
**Morning**:
- Create database schema (tables, triggers, RLS)
- Write migration scripts
- Implement credit deduction function

**Afternoon**:
- Build credit-manager service
- Create API endpoints (balance, deduct)
- Unit tests for core logic

### Day 2: Stripe + UI + Email
**Morning**:
- Set up Stripe products and webhook
- Implement checkout session creation
- Build webhook handler

**Afternoon**:
- Create CreditIndicator component
- Build low credit warning modal
- Set up email templates
- E2E testing

## Dev Agent Record

### Prerequisites Checklist
- [ ] Stripe account created (test + live modes)
- [ ] Stripe API keys stored in environment variables
- [ ] Email service selected and configured (Resend recommended)
- [ ] Email templates created
- [ ] Terms of Service drafted
- [ ] Privacy Policy drafted
- [ ] Refund policy defined

### Implementation Checklist
- [ ] Database schema created and migrated
- [ ] Freemium credit grant trigger working
- [ ] Credit deduction API with atomic transactions
- [ ] Stripe product catalog configured
- [ ] Checkout session creation endpoint
- [ ] Webhook handler with signature verification
- [ ] CreditIndicator UI component
- [ ] Low credit warning modal
- [ ] Welcome email sent on registration
- [ ] Payment confirmation email
- [ ] Unit tests (90%+ coverage)
- [ ] Integration tests (Stripe, email)
- [ ] E2E tests (freemium flow, purchase flow)
- [ ] Security audit (RLS, webhooks, rate limiting)

### Technical Notes
**Stripe Configuration**:
- Use Checkout Sessions for PCI compliance
- Configure webhook endpoint before going live
- Test webhooks with Stripe CLI: `stripe listen --forward-to localhost:3000/api/stripe/webhook`

**Email Service**:
- Resend recommended for React email templates
- Configure SPF/DKIM for domain verification
- Use transactional templates for consistency

**Legal Requirements**:
- Display ToS/Privacy Policy links during checkout
- Require acceptance before first purchase
- Store acceptance timestamp

## QA Results

*This section will be populated by the QA Agent upon story completion*
